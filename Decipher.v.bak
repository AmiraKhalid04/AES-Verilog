module Decipher(
    input[0:127] in,
    input[0:1407] words,
    output[0:127] out,
    input clk
    // input [4:0] round
);

    integer round = -1;

    wire [0:127] inafter_AddKey, inafter_InvShiftRow, inafter_InvSubBytes, inafter_InvMixColumns;
    reg [0:127] state, inbefore_AddKey;
    
    wire [0:127] inv_sr;
    //inverse_shift_rows U1(state, inafter_InvShiftRow);
    inverse_shift_rows U1(inv_sr, inafter_InvShiftRow);
    inv_sub_bytes U2(inafter_InvShiftRow, inafter_InvSubBytes);
    add_round_key U3(inbefore_AddKey, words[(128*(-round+10))+:128], inafter_AddKey);
    InvMixColumns U4(inafter_AddKey, inafter_InvMixColumns);


    // desperate tries
   // assign inv_sr=(round == 0)? inafter_AddKey:inafter_InvMixColumns;
   assign inv_sr=(round == 0)? in^ words[(128*(10))+:128]:inafter_InvMixColumns;
    assign inbefore_AddKey =inafter_InvSubBytes; 
    //assign inbefore_AddKey = (round == 10)? in:state;
    // assign out = (round == 0)? in:inafter_AddKey;
     assign out =(round == 10)? inafter_AddKey:inafter_InvMixColumns;    // 9 or 10

    //assign out =(round == 10)?inafter_AddKey:state;

    //assign out = state;
    always @(posedge clk) begin
        if(round < 10) begin
            // if (round == 10) begin
            //     inbefore_AddKey <= in;
            //     state <= inafter_AddKey;
                
            // end else if(round-10 < 10) begin
            //     inbefore_AddKey <= inafter_InvSubBytes;
            //     state <= inafter_InvMixColumns;
                
            // end else if(round-10 == 10) begin
            //     inbefore_AddKey <= inafter_InvSubBytes;
            //     state <= inafter_AddKey;
              
            // end
            // if (round == 0) begin
            //     inbefore_AddKey <= in;
            // end
            // else
            // inbefore_AddKey <= inafter_InvSubBytes;

            round <= round + 1;
        end
    end
endmodule

// 0 10
// 10 20